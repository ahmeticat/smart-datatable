{"version":3,"file":"analyse-sources.transform.js","sourceRoot":"","sources":["../../../../src/lib/ng-v5/init/analyse-sources.transform.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ng from '@angular/compiler-cli';\nimport * as ts from 'typescript';\nimport { pipe } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport * as log from '../../util/log';\nimport { Transform } from '../../brocc/transform';\nimport { isEntryPoint, EntryPointNode } from '../nodes';\nimport { cacheCompilerHost } from '../../ts/cache-compiler-host';\nimport { unique } from '../../util/array';\nimport { BuildGraph } from '../../brocc/build-graph';\nimport { ensureUnixPath } from '../../util/path';\n\nexport const analyseSourcesTransform: Transform = pipe(\n  map(graph => {\n    const entryPoints = graph.filter(x => isEntryPoint(x) && x.state !== 'done') as EntryPointNode[];\n    for (let entryPoint of entryPoints) {\n      analyseEntryPoint(graph, entryPoint, entryPoints);\n    }\n\n    return graph;\n  }),\n);\n\n/**\n * Analyses an entrypoint, searching for TypeScript dependencies and additional resources (Templates and Stylesheets).\n *\n * @param graph Build graph\n * @param entryPoint Current entry point that should be analysed.\n * @param entryPoints List of all entry points.\n */\nfunction analyseEntryPoint(graph: BuildGraph, entryPoint: EntryPointNode, entryPoints: EntryPointNode[]) {\n  const { analysisModuleResolutionCache, oldPrograms, analysisSourcesFileCache } = entryPoint.cache;\n  const oldProgram = oldPrograms && (oldPrograms['analysis'] as ts.Program | undefined);\n  const { moduleId } = entryPoint.data.entryPoint;\n\n  log.debug(`Analysing sources for ${moduleId}`);\n\n  const tsConfigOptions = {\n    ...entryPoint.data.tsConfig.options,\n    skipLibCheck: true,\n    types: [],\n  };\n\n  const compilerHost = cacheCompilerHost(\n    graph,\n    entryPoint,\n    tsConfigOptions,\n    analysisModuleResolutionCache,\n    undefined,\n    analysisSourcesFileCache,\n  );\n\n  compilerHost.resolveModuleNames = (moduleNames: string[], containingFile: string) => {\n    return moduleNames.map(moduleName => {\n      if (!moduleName.startsWith('.')) {\n        return undefined;\n      }\n\n      const { resolvedModule } = ts.resolveModuleName(\n        moduleName,\n        ensureUnixPath(containingFile),\n        tsConfigOptions,\n        compilerHost,\n        analysisModuleResolutionCache,\n      );\n\n      return resolvedModule;\n    });\n  };\n\n  const program: ts.Program = ts.createProgram(\n    entryPoint.data.tsConfig.rootNames,\n    tsConfigOptions,\n    compilerHost,\n    oldProgram,\n  );\n\n  const diagnostics = program.getOptionsDiagnostics();\n  if (diagnostics.length) {\n    throw new Error(ng.formatDiagnostics(diagnostics));\n  }\n\n  // this is a workaround due to the below\n  // https://github.com/angular/angular/issues/24010\n  let moduleStatements: string[] = [];\n  program\n    .getSourceFiles()\n    .filter(x => !/node_modules|\\.ngfactory|\\.ngstyle|(\\.d\\.ts$)/.test(x.fileName))\n    .forEach(sourceFile => {\n      sourceFile.statements\n        .filter(x => ts.isImportDeclaration(x) || ts.isExportDeclaration(x))\n        .forEach((node: ts.ImportDeclaration | ts.ExportDeclaration) => {\n          const { moduleSpecifier } = node;\n          if (!moduleSpecifier) {\n            return;\n          }\n\n          const text = moduleSpecifier.getText();\n          const trimmedText = text.substring(1, text.length - 1);\n          if (!trimmedText.startsWith('.')) {\n            moduleStatements.push(trimmedText);\n          }\n        });\n    });\n\n  log.debug(\n    `tsc program structure is reused: ${oldProgram ? (oldProgram as any).structureIsReused : 'No old program'}`,\n  );\n\n  entryPoint.cache.oldPrograms = { ...entryPoint.cache.oldPrograms, ['analysis']: program };\n\n  moduleStatements = unique(moduleStatements);\n  moduleStatements.forEach(moduleName => {\n    const dep = entryPoints.find(ep => ep.data.entryPoint.moduleId === moduleName);\n    if (dep) {\n      log.debug(`Found entry point dependency: ${moduleId} -> ${moduleName}`);\n\n      if (moduleId === moduleName) {\n        throw new Error(`Entry point ${moduleName} has a circular dependency on itself.`);\n      }\n\n      entryPoint.dependsOn(dep);\n    }\n  });\n}\n"]}