{"version":3,"file":"ctor-parameters.js","sourceRoot":"","sources":["../../../src/lib/ts/ctor-parameters.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nexport function downlevelConstructorParameters(\n  getTypeChecker: () => ts.TypeChecker,\n): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => {\n    const transformer = decoratorDownlevelTransformer(getTypeChecker(), []);\n\n    return transformer(context);\n  };\n}\n\n// The following is sourced from tsickle with local modifications\n// Only the creation of `ctorParameters` is retained\n// https://github.com/angular/tsickle/blob/0ceb7d6bc47f6945a6c4c09689f1388eb48f5c07/src/decorator_downlevel_transformer.ts\n//\n\n/**\n * Extracts the type of the decorator (the function or expression invoked), as well as all the\n * arguments passed to the decorator. Returns an AST with the form:\n *\n *     // For @decorator(arg1, arg2)\n *     { type: decorator, args: [arg1, arg2] }\n */\nfunction extractMetadataFromSingleDecorator(\n  decorator: ts.Decorator,\n  diagnostics: ts.Diagnostic[],\n): ts.ObjectLiteralExpression {\n  const metadataProperties: ts.ObjectLiteralElementLike[] = [];\n  const expr = decorator.expression;\n  switch (expr.kind) {\n    case ts.SyntaxKind.Identifier:\n      // The decorator was a plain @Foo.\n      metadataProperties.push(ts.createPropertyAssignment('type', expr));\n      break;\n    case ts.SyntaxKind.CallExpression:\n      // The decorator was a call, like @Foo(bar).\n      const call = expr as ts.CallExpression;\n      metadataProperties.push(ts.createPropertyAssignment('type', call.expression));\n      if (call.arguments.length) {\n        const args: ts.Expression[] = [];\n        for (const arg of call.arguments) {\n          args.push(arg);\n        }\n        const argsArrayLiteral = ts.createArrayLiteral(args);\n        argsArrayLiteral.elements.hasTrailingComma = true;\n        metadataProperties.push(ts.createPropertyAssignment('args', argsArrayLiteral));\n      }\n      break;\n    default:\n      diagnostics.push({\n        file: decorator.getSourceFile(),\n        start: decorator.getStart(),\n        length: decorator.getEnd() - decorator.getStart(),\n        messageText: `${ts.SyntaxKind[decorator.kind]} not implemented in gathering decorator metadata`,\n        category: ts.DiagnosticCategory.Error,\n        code: 0,\n      });\n      break;\n  }\n  return ts.createObjectLiteral(metadataProperties);\n}\n\n/**\n * createCtorParametersClassProperty creates a static 'ctorParameters' property containing\n * downleveled decorator information.\n *\n * The property contains an arrow function that returns an array of object literals of the shape:\n *     static ctorParameters = () => [{\n *       type: SomeClass|undefined,  // the type of the param that's decorated, if it's a value.\n *       decorators: [{\n *         type: DecoratorFn,  // the type of the decorator that's invoked.\n *         args: [ARGS],       // the arguments passed to the decorator.\n *       }]\n *     }];\n */\nfunction createCtorParametersClassProperty(\n  diagnostics: ts.Diagnostic[],\n  entityNameToExpression: (n: ts.EntityName) => ts.Expression | undefined,\n  ctorParameters: ParameterDecorationInfo[],\n  typeChecker: ts.TypeChecker,\n): ts.PropertyDeclaration {\n  const params: ts.Expression[] = [];\n\n  for (const ctorParam of ctorParameters) {\n    if (!ctorParam.type && ctorParam.decorators.length === 0) {\n      params.push(ts.createNull());\n      continue;\n    }\n\n    const paramType = ctorParam.type\n      ? typeReferenceToExpression(entityNameToExpression, ctorParam.type, typeChecker)\n      : undefined;\n    const members = [ts.createPropertyAssignment('type', paramType || ts.createIdentifier('undefined'))];\n\n    const decorators: ts.ObjectLiteralExpression[] = [];\n    for (const deco of ctorParam.decorators) {\n      decorators.push(extractMetadataFromSingleDecorator(deco, diagnostics));\n    }\n    if (decorators.length) {\n      members.push(ts.createPropertyAssignment('decorators', ts.createArrayLiteral(decorators)));\n    }\n    params.push(ts.createObjectLiteral(members));\n  }\n\n  const initializer = ts.createArrowFunction(\n    undefined,\n    undefined,\n    [],\n    undefined,\n    ts.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n    ts.createArrayLiteral(params, true),\n  );\n\n  const ctorProp = ts.createProperty(\n    undefined,\n    [ts.createToken(ts.SyntaxKind.StaticKeyword)],\n    'ctorParameters',\n    undefined,\n    undefined,\n    initializer,\n  );\n\n  return ctorProp;\n}\n\n/**\n * Returns an expression representing the (potentially) value part for the given node.\n *\n * This is a partial re-implementation of TypeScript's serializeTypeReferenceNode. This is a\n * workaround for https://github.com/Microsoft/TypeScript/issues/17516 (serializeTypeReferenceNode\n * not being exposed). In practice this implementation is sufficient for Angular's use of type\n * metadata.\n */\nfunction typeReferenceToExpression(\n  entityNameToExpression: (n: ts.EntityName) => ts.Expression | undefined,\n  node: ts.TypeNode,\n  typeChecker: ts.TypeChecker,\n): ts.Expression | undefined {\n  let kind = node.kind;\n  if (ts.isLiteralTypeNode(node)) {\n    // Treat literal types like their base type (boolean, string, number).\n    kind = node.literal.kind;\n  }\n  switch (kind) {\n    case ts.SyntaxKind.FunctionType:\n    case ts.SyntaxKind.ConstructorType:\n      return ts.createIdentifier('Function');\n    case ts.SyntaxKind.ArrayType:\n    case ts.SyntaxKind.TupleType:\n      return ts.createIdentifier('Array');\n    case ts.SyntaxKind.TypePredicate:\n    case ts.SyntaxKind.TrueKeyword:\n    case ts.SyntaxKind.FalseKeyword:\n    case ts.SyntaxKind.BooleanKeyword:\n      return ts.createIdentifier('Boolean');\n    case ts.SyntaxKind.StringLiteral:\n    case ts.SyntaxKind.StringKeyword:\n      return ts.createIdentifier('String');\n    case ts.SyntaxKind.ObjectKeyword:\n      return ts.createIdentifier('Object');\n    case ts.SyntaxKind.NumberKeyword:\n    case ts.SyntaxKind.NumericLiteral:\n      return ts.createIdentifier('Number');\n    case ts.SyntaxKind.TypeReference:\n      const typeRef = node as ts.TypeReferenceNode;\n      let typeSymbol = typeChecker.getSymbolAtLocation(typeRef.typeName);\n      if (typeSymbol && typeSymbol.flags & ts.SymbolFlags.Alias) {\n        typeSymbol = typeChecker.getAliasedSymbol(typeSymbol);\n      }\n\n      if (!typeSymbol || !(typeSymbol.flags & ts.SymbolFlags.Value)) {\n        return undefined;\n      }\n\n      const type = typeChecker.getTypeOfSymbolAtLocation(typeSymbol, typeRef);\n      if (!type || typeChecker.getSignaturesOfType(type, ts.SignatureKind.Construct).length === 0) {\n        return undefined;\n      }\n\n      // Ignore any generic types, just return the base type.\n      return entityNameToExpression(typeRef.typeName);\n    default:\n      return undefined;\n  }\n}\n\n/** ParameterDecorationInfo describes the information for a single constructor parameter. */\ninterface ParameterDecorationInfo {\n  /**\n   * The type declaration for the parameter. Only set if the type is a value (e.g. a class, not an\n   * interface).\n   */\n  type: ts.TypeNode | null;\n  /** The list of decorators found on the parameter, null if none. */\n  decorators: ts.Decorator[];\n}\n\n/**\n * Transformer factory for the decorator downlevel transformer. See fileoverview for details.\n */\nexport function decoratorDownlevelTransformer(\n  typeChecker: ts.TypeChecker,\n  diagnostics: ts.Diagnostic[],\n): (context: ts.TransformationContext) => ts.Transformer<ts.SourceFile> {\n  return (context: ts.TransformationContext) => {\n    const parameterTypeSymbols = new Set<ts.Symbol>();\n\n    /**\n     * Converts an EntityName (from a type annotation) to an expression (accessing a value).\n     *\n     * For a given ts.EntityName, this walks depth first to find the leftmost ts.Identifier, then\n     * converts the path into property accesses.\n     *\n     */\n    function entityNameToExpression(name: ts.EntityName): ts.Expression | undefined {\n      if (ts.isIdentifier(name)) {\n        const typeSymbol = typeChecker.getSymbolAtLocation(name);\n        if (typeSymbol) {\n          parameterTypeSymbols.add(typeSymbol);\n        }\n\n        // Based on TS's strategy to allow the checker to reach this identifier\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/microsoft/TypeScript/blob/7f47a08a5e9874f0f97a667bd81eebddec61247c/src/compiler/transformers/ts.ts#L2093\n        const exp = ts.getMutableClone(name);\n        exp.flags &= ~ts.NodeFlags.Synthesized;\n        ((exp as unknown) as { original: undefined }).original = undefined;\n        exp.parent = ts.getParseTreeNode(name.getSourceFile());\n\n        return exp;\n      }\n      const ref = entityNameToExpression(name.left);\n      if (!ref) {\n        return undefined;\n      }\n\n      return ts.createPropertyAccess(ref, name.right);\n    }\n\n    function classMemberVisitor(node: ts.Node): ts.VisitResult<ts.Node> {\n      if (!ts.isConstructorDeclaration(node) || !node.body) {\n        return visitor(node);\n      }\n\n      const parametersInfo: ParameterDecorationInfo[] = [];\n      for (const param of node.parameters) {\n        const paramInfo: ParameterDecorationInfo = { decorators: [], type: null };\n\n        for (const decorator of param.decorators || []) {\n          paramInfo.decorators.push(decorator);\n        }\n        if (param.type) {\n          // param has a type provided, e.g. \"foo: Bar\".\n          // The type will be emitted as a value expression in entityNameToExpression, which takes\n          // care not to emit anything for types that cannot be expressed as a value (e.g.\n          // interfaces).\n          paramInfo.type = param.type;\n        }\n        parametersInfo.push(paramInfo);\n      }\n\n      if (parametersInfo.length > 0) {\n        const ctorProperty = createCtorParametersClassProperty(\n          diagnostics,\n          entityNameToExpression,\n          parametersInfo,\n          typeChecker,\n        );\n\n        return [node, ctorProperty];\n      } else {\n        return node;\n      }\n    }\n\n    function visitor<T extends ts.Node>(node: T): ts.Node {\n      if (ts.isClassDeclaration(node) && node.decorators && node.decorators.length > 0) {\n        return ts.updateClassDeclaration(\n          node,\n          node.decorators,\n          node.modifiers,\n          node.name,\n          node.typeParameters,\n          node.heritageClauses,\n          ts.visitNodes(node.members, classMemberVisitor),\n        );\n      } else {\n        return ts.visitEachChild(node, visitor, context);\n      }\n    }\n\n    return (sf: ts.SourceFile) => {\n      parameterTypeSymbols.clear();\n\n      return ts.visitEachChild(\n        visitor(sf) as ts.SourceFile,\n        function visitImports(node: ts.Node): ts.Node {\n          if ((ts.isImportSpecifier(node) || ts.isNamespaceImport(node) || ts.isImportClause(node)) && node.name) {\n            const importSymbol = typeChecker.getSymbolAtLocation(node.name);\n            if (importSymbol && parameterTypeSymbols.has(importSymbol)) {\n              // Using a clone prevents TS from removing the import specifier\n              return ts.getMutableClone(node);\n            }\n          }\n\n          return ts.visitEachChild(node, visitImports, context);\n        },\n        context,\n      );\n    };\n  };\n}\n"]}